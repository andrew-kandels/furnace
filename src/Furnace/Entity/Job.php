<?php
namespace Furnace\Entity;

use Contain\Entity\AbstractEntity;
use Contain\Entity\Property\Property;

/**
 * Job Entity (auto-generated by the Contain module)
 *
 * This instance should not be edited directly. Edit the definition file instead
 * and recompile.
 */
class Job extends AbstractEntity
{

    protected $inputFilter = 'Furnace\Entity\Filter\Job';
    protected $messages = array();

    /**
     * Initializes the properties of this entity.
     *
     * @return  $this
     */
    public function init()
    {
        $this->define('name', 'string', array (
  'required' => true,
  'primary' => true,
  'filters' => 
  array (
    0 => 
    array (
      'name' => 'StringTrim',
    ),
  ),
  'validators' => 
  array (
    0 => 
    array (
      'name' => 'Regex',
      'options' => 
      array (
        'pattern' => '/^[a-zA-Z][a-zA-Z0-9-_]*$/',
        'messages' => 
        array (
          'regexNotMatch' => 'Job names should start with a letter and contain only letters, numbers, underscores and dashes.',
        ),
      ),
    ),
    1 => 
    array (
      'name' => 'StringLength',
      0 => 
      array (
        'min' => 0,
        'max' => 60,
      ),
    ),
  ),
  'attributes' => 
  array (
    'required' => true,
    'class' => 'input-large',
  ),
  'options' => 
  array (
    'label' => 'Name',
    'help-block' => 'Unique name used to identify the job.',
  ),
));
        $this->define('description', 'string', array (
  'filters' => 
  array (
    0 => 
    array (
      'name' => 'StringTrim',
    ),
    1 => 
    array (
      'name' => 'StripTags',
    ),
  ),
  'validators' => 
  array (
    0 => 
    array (
      'name' => 'StringLength',
      0 => 
      array (
        'min' => 0,
        'max' => 140,
      ),
    ),
  ),
  'type' => 'textarea',
  'attributes' => 
  array (
    'rows' => 2,
    'class' => 'input-xlarge',
  ),
  'options' => 
  array (
    'label' => 'Description',
    'help-block' => 'Longer description describing what the job does.',
  ),
));
        $this->define('priority', 'integer', array (
  'required' => true,
  'defaultValue' => 10,
  'type' => 'select',
  'filters' => 
  array (
    0 => 
    array (
      'name' => 'Digits',
    ),
  ),
  'validators' => 
  array (
    0 => 
    array (
      'name' => 'Digits',
    ),
  ),
  'options' => 
  array (
    'label' => 'Priority',
    'help-block' => 'Job priority in relation to other jobs, jobs with higher priorities are started first.',
    'value_options' => 
    array (
      1 => '1',
      2 => '2',
      3 => '3',
      4 => '4',
      5 => '5',
      6 => '6',
      7 => '7',
      8 => '8',
      9 => '9',
      10 => '10',
      11 => '11',
      12 => '12',
      13 => '13',
      14 => '14',
      15 => '15',
      16 => '16',
      17 => '17',
      18 => '18',
      19 => '19',
      20 => '20',
      21 => '21',
      22 => '22',
      23 => '23',
      24 => '24',
      25 => '25',
      26 => '26',
      27 => '27',
      28 => '28',
      29 => '29',
      30 => '30',
      31 => '31',
      32 => '32',
      33 => '33',
      34 => '34',
      35 => '35',
      36 => '36',
      37 => '37',
      38 => '38',
      39 => '39',
      40 => '40',
      41 => '41',
      42 => '42',
      43 => '43',
      44 => '44',
      45 => '45',
      46 => '46',
      47 => '47',
      48 => '48',
      49 => '49',
      50 => '50',
      51 => '51',
      52 => '52',
      53 => '53',
      54 => '54',
      55 => '55',
      56 => '56',
      57 => '57',
      58 => '58',
      59 => '59',
      60 => '60',
      61 => '61',
      62 => '62',
      63 => '63',
      64 => '64',
      65 => '65',
      66 => '66',
      67 => '67',
      68 => '68',
      69 => '69',
      70 => '70',
      71 => '71',
      72 => '72',
      73 => '73',
      74 => '74',
      75 => '75',
      76 => '76',
      77 => '77',
      78 => '78',
      79 => '79',
      80 => '80',
      81 => '81',
      82 => '82',
      83 => '83',
      84 => '84',
      85 => '85',
      86 => '86',
      87 => '87',
      88 => '88',
      89 => '89',
      90 => '90',
      91 => '91',
      92 => '92',
      93 => '93',
      94 => '94',
      95 => '95',
      96 => '96',
      97 => '97',
      98 => '98',
      99 => '99',
      100 => '100',
    ),
  ),
  'attributes' => 
  array (
    'class' => 'input-small',
  ),
));
        $this->define('schedule', 'string', array (
  'required' => true,
  'defaultValue' => 'daily',
  'type' => 'select',
  'options' => 
  array (
    'label' => 'Schedule',
    'value_options' => 
    array (
      'once' => 'Once',
      'daily' => 'Daily',
      'weekly' => 'Weekly',
      'monthly' => 'Monthly',
    ),
  ),
  'attributes' => 
  array (
    'class' => 'input-medium',
  ),
));
        $this->define('dependencies', 'list', array (
  'type' => 'string',
  'className' => '',
));
        $this->define('startAt', 'dateTime', array (
  'type' => 'date',
  'required' => true,
  'attributes' => 
  array (
    'required' => true,
    'class' => 'input-medium',
  ),
  'options' => 
  array (
    'label' => 'Starts',
    'class' => 'input-large',
    'help-block' => 'Uses the time and/or date depending on the type of schedule.',
  ),
  'dateFormat' => 'Y-m-d H:i:s',
));
        $this->define('queuedAt', 'dateTime', array (
  'dateFormat' => 'Y-m-d H:i:s',
));
        $this->define('startedAt', 'dateTime', array (
  'dateFormat' => 'Y-m-d H:i:s',
));
        $this->define('completedAt', 'dateTime', array (
  'dateFormat' => 'Y-m-d H:i:s',
));
        $this->define('percentComplete', 'integer');
        $this->define('error', 'boolean');
        $this->define('pidOf', 'integer');
        $this->define('pidCmd', 'string');
        $this->define('messages', 'list', array (
  'type' => 'string',
  'className' => '',
));
        $this->define('history', 'listEntity', array (
  'className' => 'Furnace\\Entity\\History',
));
        $this->define('logs', 'list', array (
  'type' => 'string',
  'className' => '',
));
            }


    /**
     * Accessor getter for the name property
     *
     * @return  See: Contain\Entity\Property\Type\StringType::getValue()
     */
    public function getName()
    {
        return $this->get('name');
    }

    /**
     * Accessor setter for the name property
     *
     * @param   See: Contain\Entity\Property\Type\StringType::parse()
     * @return  $this
     */
    public function setName($value)
    {
        return $this->set('name', $value);
    }

    /**
     * Accessor existence checker for the name property
     *
     * @return  boolean
     */
    public function hasName()
    {
        $property = $this->property('name');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the description property
     *
     * @return  See: Contain\Entity\Property\Type\StringType::getValue()
     */
    public function getDescription()
    {
        return $this->get('description');
    }

    /**
     * Accessor setter for the description property
     *
     * @param   See: Contain\Entity\Property\Type\StringType::parse()
     * @return  $this
     */
    public function setDescription($value)
    {
        return $this->set('description', $value);
    }

    /**
     * Accessor existence checker for the description property
     *
     * @return  boolean
     */
    public function hasDescription()
    {
        $property = $this->property('description');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the priority property
     *
     * @return  See: Contain\Entity\Property\Type\IntegerType::getValue()
     */
    public function getPriority()
    {
        return $this->get('priority');
    }

    /**
     * Accessor setter for the priority property
     *
     * @param   See: Contain\Entity\Property\Type\IntegerType::parse()
     * @return  $this
     */
    public function setPriority($value)
    {
        return $this->set('priority', $value);
    }

    /**
     * Accessor existence checker for the priority property
     *
     * @return  boolean
     */
    public function hasPriority()
    {
        $property = $this->property('priority');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the schedule property
     *
     * @return  See: Contain\Entity\Property\Type\StringType::getValue()
     */
    public function getSchedule()
    {
        return $this->get('schedule');
    }

    /**
     * Accessor setter for the schedule property
     *
     * @param   See: Contain\Entity\Property\Type\StringType::parse()
     * @return  $this
     */
    public function setSchedule($value)
    {
        return $this->set('schedule', $value);
    }

    /**
     * Accessor existence checker for the schedule property
     *
     * @return  boolean
     */
    public function hasSchedule()
    {
        $property = $this->property('schedule');
        return !($property->isUnset() || $property->isEmpty());
    }
    /**
     * Searches for a value and returns its index or FALSE if not found.
     *
     * @param   mixed                           Value to search for
     * @param   boolean                         Strict type checking
     * @return  integer|false
     */
    public function indexOfDependencies($value, $strict = false)
    {
        return $this->indexOf('dependencies', $value, $strict);
    }

    /**
     * Sets a value for a list item at a given index.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function putDependencies($index)
    {
        return $this->put('dependencies', $index);
    }

    /**
     * Fetches a list item by its numerical index position.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function atDependencies($index)
    {
        return $this->at('dependencies', $index);
    }

    /**
     * Prepends a value to a list property.
     *
     * @param   mixed                           Value to prepend
     * @return  $this
     */
    public function unshiftDependencies($value)
    {
        return $this->unshift('dependencies', $value);
    }

    /**
     * Appends a value to a list property.
     *
     * @param   mixed                           Value to append
     * @return  $this
     */
    public function pushDependencies($value)
    {
        return $this->push('dependencies', $value);
    }
  
    /**
     * Removes a property from the end of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function popDependencies($value)
    {
        return $this->pop('dependencies', $value);
    }

    /**
     * Removes a property from the beginning of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function shiftDependencies($value)
    {
        return $this->shift('dependencies', $value);
    }

    /**
     * Extracts a slice of the list.
     *
     * @param   integer                         Offset
     * @param   integer|null                    Length
     * @return  array
     */
    public function sliceDependencies($offset, $length = null)
    {
        return $this->slice('dependencies', $offset, $length);
    }

    /**
     * Merges the list with another array.
     *
     * @param   array                           Array to merge with
     * @param   boolean                         True if existing list is the source vs. target
     * @return  array
     */
    public function mergeDependencies($arr, $source = true)
    {
        return $this->merge('dependencies', $arr, $source);
    }

    /**
     * Removes a single item from the list by value if it exists.
     *
     * @param   mixed                           Value to remove
     * @return  array
     */
    public function removeDependencies($value)
    {
        return $this->remove('dependencies', $value);
    }

    /**
     * Adds an item to the list if it doesn't already exist.
     *
     * @param   mixed                           Value to add
     * @param   boolean                         True for prepend, false for append
     * @return  $this
     */
    public function addDependencies($value, $prepend = true)
    {
        return $this->add('dependencies', $value, $prepend);
    }

    /**
     * Accessor getter for the dependencies property
     *
     * @return  See: Contain\Entity\Property\Type\ListType::getValue()
     */
    public function getDependencies()
    {
        return $this->get('dependencies');
    }

    /**
     * Accessor setter for the dependencies property
     *
     * @param   See: Contain\Entity\Property\Type\ListType::parse()
     * @return  $this
     */
    public function setDependencies($value)
    {
        return $this->set('dependencies', $value);
    }

    /**
     * Accessor existence checker for the dependencies property
     *
     * @return  boolean
     */
    public function hasDependencies()
    {
        $property = $this->property('dependencies');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the startAt property
     *
     * @return  See: Contain\Entity\Property\Type\DateTimeType::getValue()
     */
    public function getStartAt()
    {
        return $this->get('startAt');
    }

    /**
     * Accessor setter for the startAt property
     *
     * @param   See: Contain\Entity\Property\Type\DateTimeType::parse()
     * @return  $this
     */
    public function setStartAt($value)
    {
        return $this->set('startAt', $value);
    }

    /**
     * Accessor existence checker for the startAt property
     *
     * @return  boolean
     */
    public function hasStartAt()
    {
        $property = $this->property('startAt');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the queuedAt property
     *
     * @return  See: Contain\Entity\Property\Type\DateTimeType::getValue()
     */
    public function getQueuedAt()
    {
        return $this->get('queuedAt');
    }

    /**
     * Accessor setter for the queuedAt property
     *
     * @param   See: Contain\Entity\Property\Type\DateTimeType::parse()
     * @return  $this
     */
    public function setQueuedAt($value)
    {
        return $this->set('queuedAt', $value);
    }

    /**
     * Accessor existence checker for the queuedAt property
     *
     * @return  boolean
     */
    public function hasQueuedAt()
    {
        $property = $this->property('queuedAt');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the startedAt property
     *
     * @return  See: Contain\Entity\Property\Type\DateTimeType::getValue()
     */
    public function getStartedAt()
    {
        return $this->get('startedAt');
    }

    /**
     * Accessor setter for the startedAt property
     *
     * @param   See: Contain\Entity\Property\Type\DateTimeType::parse()
     * @return  $this
     */
    public function setStartedAt($value)
    {
        return $this->set('startedAt', $value);
    }

    /**
     * Accessor existence checker for the startedAt property
     *
     * @return  boolean
     */
    public function hasStartedAt()
    {
        $property = $this->property('startedAt');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the completedAt property
     *
     * @return  See: Contain\Entity\Property\Type\DateTimeType::getValue()
     */
    public function getCompletedAt()
    {
        return $this->get('completedAt');
    }

    /**
     * Accessor setter for the completedAt property
     *
     * @param   See: Contain\Entity\Property\Type\DateTimeType::parse()
     * @return  $this
     */
    public function setCompletedAt($value)
    {
        return $this->set('completedAt', $value);
    }

    /**
     * Accessor existence checker for the completedAt property
     *
     * @return  boolean
     */
    public function hasCompletedAt()
    {
        $property = $this->property('completedAt');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the percentComplete property
     *
     * @return  See: Contain\Entity\Property\Type\IntegerType::getValue()
     */
    public function getPercentComplete()
    {
        return $this->get('percentComplete');
    }

    /**
     * Accessor setter for the percentComplete property
     *
     * @param   See: Contain\Entity\Property\Type\IntegerType::parse()
     * @return  $this
     */
    public function setPercentComplete($value)
    {
        return $this->set('percentComplete', $value);
    }

    /**
     * Accessor existence checker for the percentComplete property
     *
     * @return  boolean
     */
    public function hasPercentComplete()
    {
        $property = $this->property('percentComplete');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the error property
     *
     * @return  See: Contain\Entity\Property\Type\BooleanType::getValue()
     */
    public function getError()
    {
        return $this->get('error');
    }

    /**
     * Accessor setter for the error property
     *
     * @param   See: Contain\Entity\Property\Type\BooleanType::parse()
     * @return  $this
     */
    public function setError($value)
    {
        return $this->set('error', $value);
    }

    /**
     * Accessor existence checker for the error property
     *
     * @return  boolean
     */
    public function hasError()
    {
        $property = $this->property('error');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the pidOf property
     *
     * @return  See: Contain\Entity\Property\Type\IntegerType::getValue()
     */
    public function getPidOf()
    {
        return $this->get('pidOf');
    }

    /**
     * Accessor setter for the pidOf property
     *
     * @param   See: Contain\Entity\Property\Type\IntegerType::parse()
     * @return  $this
     */
    public function setPidOf($value)
    {
        return $this->set('pidOf', $value);
    }

    /**
     * Accessor existence checker for the pidOf property
     *
     * @return  boolean
     */
    public function hasPidOf()
    {
        $property = $this->property('pidOf');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Accessor getter for the pidCmd property
     *
     * @return  See: Contain\Entity\Property\Type\StringType::getValue()
     */
    public function getPidCmd()
    {
        return $this->get('pidCmd');
    }

    /**
     * Accessor setter for the pidCmd property
     *
     * @param   See: Contain\Entity\Property\Type\StringType::parse()
     * @return  $this
     */
    public function setPidCmd($value)
    {
        return $this->set('pidCmd', $value);
    }

    /**
     * Accessor existence checker for the pidCmd property
     *
     * @return  boolean
     */
    public function hasPidCmd()
    {
        $property = $this->property('pidCmd');
        return !($property->isUnset() || $property->isEmpty());
    }
    /**
     * Searches for a value and returns its index or FALSE if not found.
     *
     * @param   mixed                           Value to search for
     * @param   boolean                         Strict type checking
     * @return  integer|false
     */
    public function indexOfMessages($value, $strict = false)
    {
        return $this->indexOf('messages', $value, $strict);
    }

    /**
     * Sets a value for a list item at a given index.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function putMessages($index)
    {
        return $this->put('messages', $index);
    }

    /**
     * Fetches a list item by its numerical index position.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function atMessages($index)
    {
        return $this->at('messages', $index);
    }

    /**
     * Prepends a value to a list property.
     *
     * @param   mixed                           Value to prepend
     * @return  $this
     */
    public function unshiftMessages($value)
    {
        return $this->unshift('messages', $value);
    }

    /**
     * Appends a value to a list property.
     *
     * @param   mixed                           Value to append
     * @return  $this
     */
    public function pushMessages($value)
    {
        return $this->push('messages', $value);
    }
  
    /**
     * Removes a property from the end of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function popMessages($value)
    {
        return $this->pop('messages', $value);
    }

    /**
     * Removes a property from the beginning of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function shiftMessages($value)
    {
        return $this->shift('messages', $value);
    }

    /**
     * Extracts a slice of the list.
     *
     * @param   integer                         Offset
     * @param   integer|null                    Length
     * @return  array
     */
    public function sliceMessages($offset, $length = null)
    {
        return $this->slice('messages', $offset, $length);
    }

    /**
     * Merges the list with another array.
     *
     * @param   array                           Array to merge with
     * @param   boolean                         True if existing list is the source vs. target
     * @return  array
     */
    public function mergeMessages($arr, $source = true)
    {
        return $this->merge('messages', $arr, $source);
    }

    /**
     * Removes a single item from the list by value if it exists.
     *
     * @param   mixed                           Value to remove
     * @return  array
     */
    public function removeMessages($value)
    {
        return $this->remove('messages', $value);
    }

    /**
     * Adds an item to the list if it doesn't already exist.
     *
     * @param   mixed                           Value to add
     * @param   boolean                         True for prepend, false for append
     * @return  $this
     */
    public function addMessages($value, $prepend = true)
    {
        return $this->add('messages', $value, $prepend);
    }

    /**
     * Accessor getter for the messages property
     *
     * @return  See: Contain\Entity\Property\Type\ListType::getValue()
     */
    public function getMessages()
    {
        return $this->get('messages');
    }

    /**
     * Accessor setter for the messages property
     *
     * @param   See: Contain\Entity\Property\Type\ListType::parse()
     * @return  $this
     */
    public function setMessages($value)
    {
        return $this->set('messages', $value);
    }

    /**
     * Accessor existence checker for the messages property
     *
     * @return  boolean
     */
    public function hasMessages()
    {
        $property = $this->property('messages');
        return !($property->isUnset() || $property->isEmpty());
    }
    /**
     * Searches for a value and returns its index or FALSE if not found.
     *
     * @param   mixed                           Value to search for
     * @param   boolean                         Strict type checking
     * @return  integer|false
     */
    public function indexOfHistory($value, $strict = false)
    {
        return $this->indexOf('history', $value, $strict);
    }

    /**
     * Sets a value for a list item at a given index.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function putHistory($index)
    {
        return $this->put('history', $index);
    }

    /**
     * Fetches a list item by its numerical index position.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function atHistory($index)
    {
        return $this->at('history', $index);
    }

    /**
     * Prepends a value to a list property.
     *
     * @param   mixed                           Value to prepend
     * @return  $this
     */
    public function unshiftHistory($value)
    {
        return $this->unshift('history', $value);
    }

    /**
     * Appends a value to a list property.
     *
     * @param   mixed                           Value to append
     * @return  $this
     */
    public function pushHistory($value)
    {
        return $this->push('history', $value);
    }
  
    /**
     * Removes a property from the end of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function popHistory($value)
    {
        return $this->pop('history', $value);
    }

    /**
     * Removes a property from the beginning of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function shiftHistory($value)
    {
        return $this->shift('history', $value);
    }

    /**
     * Extracts a slice of the list.
     *
     * @param   integer                         Offset
     * @param   integer|null                    Length
     * @return  array
     */
    public function sliceHistory($offset, $length = null)
    {
        return $this->slice('history', $offset, $length);
    }

    /**
     * Merges the list with another array.
     *
     * @param   array                           Array to merge with
     * @param   boolean                         True if existing list is the source vs. target
     * @return  array
     */
    public function mergeHistory($arr, $source = true)
    {
        return $this->merge('history', $arr, $source);
    }

    /**
     * Removes a single item from the list by value if it exists.
     *
     * @param   mixed                           Value to remove
     * @return  array
     */
    public function removeHistory($value)
    {
        return $this->remove('history', $value);
    }

    /**
     * Adds an item to the list if it doesn't already exist.
     *
     * @param   mixed                           Value to add
     * @param   boolean                         True for prepend, false for append
     * @return  $this
     */
    public function addHistory($value, $prepend = true)
    {
        return $this->add('history', $value, $prepend);
    }

    /**
     * Accessor getter for the history property
     *
     * @return  See: Contain\Entity\Property\Type\ListEntityType::getValue()
     */
    public function getHistory()
    {
        return $this->get('history');
    }

    /**
     * Accessor setter for the history property
     *
     * @param   See: Contain\Entity\Property\Type\ListEntityType::parse()
     * @return  $this
     */
    public function setHistory($value)
    {
        return $this->set('history', $value);
    }

    /**
     * Accessor existence checker for the history property
     *
     * @return  boolean
     */
    public function hasHistory()
    {
        $property = $this->property('history');
        return !($property->isUnset() || $property->isEmpty());
    }
    /**
     * Searches for a value and returns its index or FALSE if not found.
     *
     * @param   mixed                           Value to search for
     * @param   boolean                         Strict type checking
     * @return  integer|false
     */
    public function indexOfLogs($value, $strict = false)
    {
        return $this->indexOf('logs', $value, $strict);
    }

    /**
     * Sets a value for a list item at a given index.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function putLogs($index)
    {
        return $this->put('logs', $index);
    }

    /**
     * Fetches a list item by its numerical index position.
     *
     * @param   string                          Property name
     * @param   integer                         Index
     * @return  mixed|null                      Value or null if unset
     */
    public function atLogs($index)
    {
        return $this->at('logs', $index);
    }

    /**
     * Prepends a value to a list property.
     *
     * @param   mixed                           Value to prepend
     * @return  $this
     */
    public function unshiftLogs($value)
    {
        return $this->unshift('logs', $value);
    }

    /**
     * Appends a value to a list property.
     *
     * @param   mixed                           Value to append
     * @return  $this
     */
    public function pushLogs($value)
    {
        return $this->push('logs', $value);
    }
  
    /**
     * Removes a property from the end of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function popLogs($value)
    {
        return $this->pop('logs', $value);
    }

    /**
     * Removes a property from the beginning of a list and returns it.
     *
     * @return  mixed                           List item (now removed)
     */
    public function shiftLogs($value)
    {
        return $this->shift('logs', $value);
    }

    /**
     * Extracts a slice of the list.
     *
     * @param   integer                         Offset
     * @param   integer|null                    Length
     * @return  array
     */
    public function sliceLogs($offset, $length = null)
    {
        return $this->slice('logs', $offset, $length);
    }

    /**
     * Merges the list with another array.
     *
     * @param   array                           Array to merge with
     * @param   boolean                         True if existing list is the source vs. target
     * @return  array
     */
    public function mergeLogs($arr, $source = true)
    {
        return $this->merge('logs', $arr, $source);
    }

    /**
     * Removes a single item from the list by value if it exists.
     *
     * @param   mixed                           Value to remove
     * @return  array
     */
    public function removeLogs($value)
    {
        return $this->remove('logs', $value);
    }

    /**
     * Adds an item to the list if it doesn't already exist.
     *
     * @param   mixed                           Value to add
     * @param   boolean                         True for prepend, false for append
     * @return  $this
     */
    public function addLogs($value, $prepend = true)
    {
        return $this->add('logs', $value, $prepend);
    }

    /**
     * Accessor getter for the logs property
     *
     * @return  See: Contain\Entity\Property\Type\ListType::getValue()
     */
    public function getLogs()
    {
        return $this->get('logs');
    }

    /**
     * Accessor setter for the logs property
     *
     * @param   See: Contain\Entity\Property\Type\ListType::parse()
     * @return  $this
     */
    public function setLogs($value)
    {
        return $this->set('logs', $value);
    }

    /**
     * Accessor existence checker for the logs property
     *
     * @return  boolean
     */
    public function hasLogs()
    {
        $property = $this->property('logs');
        return !($property->isUnset() || $property->isEmpty());
    }

    /**
     * Checks to see if the meta-data of the job indicates it's running.
     * Optional: checks to see if the reported PID is still valid (only
     * works on *nix systems with a /proc file system).
     *
     * @param   boolean                 Verify PID is running
     * @return  boolean
     */
    public function isStarted($checkPidOf = true)
    {
        if (!$this->getStartedAt() || $this->getCompletedAt()) {
            return false;
        }

        if ($checkPidOf) {
            $status = sprintf('/proc/%d/cmdline', $this->getPidOf());

            // is the PID still active?
            if (!file_exists($status)) {
                return false;
            }

            // verify the PID is for our job and wasn't simply re-used
            return $this->getPidCmd() == file_get_contents($status);
        }

        return true;
    }

    /**
     * Checks to see if the job is currently queued to run.
     *
     * @return  boolean
     */
    public function isQueued()
    {
        return $this->getQueuedAt() && !$this->getStartedAt();
    }

    /**
     * Checks to see if the job has run for a given date (defaults to
     * current date/time).
     *
     * @param   DateTime                Date/Time to check
     * @return  boolean
     */
    public function isCompleted($when = null)
    {
        $when = $this->getTimestampFromArgument($when);

        if (!$startAt = $this->getStartAt()) {
            throw new \RuntimeException('This job has no startAt, unable to determine '
                . 'whether it has been completed.'
            );
        }

        if (!$schedule = $this->getSchedule()) {
            throw new \RuntimeException('This job has no schedule, unable to determine '
                . 'whether it has been completed.'
            );
        }

        $runTimes = array();
        foreach ($this->getHistory() ?: array() as $history) {
            if ($history->getCompletedAt()) {
                $runTimes[] = $history->getCompletedAt()->getTimestamp();
            }
        }

        if ($this->getCompletedAt() && !$this->getError()) {
            $runTimes[] = $this->getCompletedAt()->getTimestamp();
        }

        switch ($schedule) {
            case 'once':
                return (boolean) $this->getCompletedAt();
                break;

            case 'daily':
                foreach ($runTimes as $runTime) {
                    if (date('Y-m-d', $runTime) == date('Y-m-d', $when)) {
                        return true;
                    }
                }
                break;

            case 'weekly':
                $oneWeek = 86400 * 7;

                foreach ($runTimes as $runTime) {
                    $diff = abs($runTime - $when);

                    if ($diff < $oneWeek) {
                        return true;
                    }
                }
                break;

            case 'monthly':
                foreach ($runTimes as $runTime) {
                    if (date('Y-m', $runTime) == date('Y-m', $when)) {
                        return true;
                    }
                }
                break;

            default:
                throw new \RuntimeException('Job does not have a recognized '
                    . 'schedule, unable to determine completedness.'
                );
                break;
        }

        return false;
    }

    /**
     * Extracts a timestamp from a given argument of DateTime, a string
     * for strtotime() or an integer representing seconds since the epoch.
     *
     * @param   DateTime|integer|string
     * @return  integer
     */
    public function getTimestampFromArgument($when = null)
    {
        if (!$when) {
            return time();
        }

        if ($when instanceof \DateTime) {
            return $when->getTimestamp();
        }

        if (is_string($when)) {
            if (!$when = strtotime($when)) {
                throw new \InvalidArgumentException('$when contains an invalid strtotime() '
                    . 'value: ' . $when
                );
            }

            return $when;
        }

        if (!is_integer($when)) {
            throw new \InvalidArgumentException('$when argument '
                . 'must be an instance of DateTime, an epoch timestamp, or a string to be '
                . 'evalulated by strtotime().'
            );
        }

        return $when;
    }

    /**
     * Retrieves resource utilization stats for the current job by
     * looking them up in the /proc filesystem on *nix systems.
     *
     * @return  array(name => value, ...)
     */
    public function getStats()
    {
        $status = sprintf('/proc/%d/status', $this->getPidOf());

        if (!file_exists($status)) {
            return array('poop' => 'bandit');
        }

        $lines = file($status, FILE_IGNORE_NEW_LINES | FILE_SKIP_EMPTY_LINES);
        $hash  = array();

        foreach ($lines as $line) {
            if (preg_match('/^([^\:]+)\:(.*)$/', trim($line), $matches)) {
                $hash[$matches[1]] = trim($matches[2]);
            }
        }

        return $hash;
    }

    /**
     * Marks the internal properties for the entity to reflect it has been
     * queued and is waiting to be started by the next available worker.
     *
     * @return  $this
     */
    public function queue()
    {
        if ($this->getQueuedAt()) {
            throw new \RuntimeException('Cannot queue job as it has already been queued.');
        }

        if ($this->getStartedAt()) {
            throw new \RuntimeException('Cannot queue job as it has already been started.');
        }

        $this->setQueuedAt(time());
        $this->setError(false);
        $this->setMessages(array(
            sprintf('Queued job at %s', date('Y-m-d H:i:s', $this->getQueuedAt()->getTimestamp())),
        ));

        return $this;
    }

    /**
     * Marks the internal properties for the entity to reflect that it has
     * been picked up by a worker and started.
     *
     * @param   boolean                 Scan *nix /proc filesystem for PID/cmdline tracking
     * @return  $this
     */
    public function start($incPidLookup = true)
    {
        if ($this->getStartedAt()) {
            throw new \RuntimeException('Cannot start job as it has already been started.');
        }

        $this->clear(array('completedAt', 'queuedAt', 'messages', 'error'));
        $this->setPercentComplete(0);
        $this->setStartedAt(time());

        $message = sprintf('Started job at %s',
            date('Y-m-d H:i:s', $this->getStartedAt()->getTimestamp())
        );

        if ($incPidLookup) {
            $pid    = getmypid();
            $status = sprintf('/proc/%d/cmdline', $pid);

            if (!file_exists($status)) {
                throw new \RuntimeException('Cannot locate this process in the /proc filesystem, '
                    . 'perhaps we\'re not on *nix?'
                );
            }

            $this->setPidOf($pid);
            $this->setPidCmd(file_get_contents($status));

            $message .= sprintf(' (pid: %d)', $pid);
        }

        $this->addMessages($message);

        return $this;
    }

    /**
     * Tracks progress for a started job. Optionally looks up resource utilization
     * in the *nix /proc filesystem.
     *
     * @param   boolean                 Include *nix /proc filesystem status report
     * @return  $this
     */
    public function progress($pct, $incPidLookup = true)
    {
        $this->setPercentComplete($pct);

        if (!$this->isStarted($incPidLookup)) {
            throw new \RuntimeException('Cannot set progress, job is no longer running.');
        }

        $message = sprintf('Job reporting %d%% progress', $pct);

        if ($incPidLookup && $this->getPidOf()) {
            $stats  = $this->getStats();
            $report = array();

            if (isset($stats['Name'])) {
                $report[] = sprintf('\'%s\' running', $stats['Name']);
            }

            if (isset($stats['Pid'])) {
                $report[] = sprintf('on pid %d', $stats['Pid']);
            }

            if (isset($stats['VmSize'])) {
                $report[] = sprintf('total memory %s', $stats['VmSize']);
            }

            if (isset($stats['VmStk']) && isset($stats['VmSwap']) && isset($stats['VmData'])) {
                $report[] = sprintf('(stack: %s, heap: %s, swap: %s)',
                    $stats['VmStk'],
                    $stats['VmData'],
                    $stats['VmSwap']
                );
            }

            if (isset($stats['Threads'])) {
                $report[] = sprintf('on %d threads', $stats['Threads']);
            }

            if (isset($stats['State'])) {
                $report[] = sprintf('reporting state: %s', $stats['State']);
            }

            if ($report) {
                $message .= '. ' . implode(' ', $report);
            }
        }

        $this->addMessages($message);

        return $this;
    }

    /**
     * Marks the internal properties for the entity to reflect that it has
     * been completed.
     *
     * @param   boolean                 Include *nix /proc filesystem stats
     * @return  $this
     */
    public function complete($incStats = true)
    {
        if ($this->getCompletedAt()) {
            throw new \RuntimeException('Cannot complete job as the completedAt property is empty.');
        }

        if (!$this->getStartedAt()) {
            throw new \RuntimeException('Cannot complete job as the startedAt property is empty.');
        }

        $this->setCompletedAt(time());

        $history = new \Furnace\Entity\History(array(
            'startedAt' => $this->getStartedAt(),
            'completedAt' => $this->getCompletedAt(),
        ));

        if ($incStats && $this->getPidOf()) {
            $history->setStats($hash = $this->getStats());
        }

        $this->unshiftHistory($history);

        $this->addMessages(sprintf('Job completed at %s',
            date('Y-m-d H:i:s', $this->getCompletedAt()->getTimestamp()))
        );

        $this->clear('startedAt');

        return $this;
    }

    /**
     * Marks the internal properties for the entity to reflect that it has
     * not been completed.
     *
     * @return  $this
     */
    public function incomplete()
    {
        if (!$this->isCompleted()) {
            throw new \RuntimeException('Job is already marked as incomplete.');
        }

        $this->clear(array(
            'queuedAt',
            'startedAt',
            'completedAt',
            'error',
        ));

        if ($history = $this->getHistory() ?: array()) {
            if ($history instanceof \ContainMapper\Cursor) {
                $history = $history->export();
            }

            array_pop($history);
            $this->setHistory($history);
        }

        return $this;
    }

    /**
     * Marks the internal properties for the entity to reflect that it has
     * completed, but failed with an error.
     *
     * @param   string                  Message describing the error
     * @param   boolean                 Include *nix /proc filesystem stats
     * @return  $this
     */
    public function fail($message = '', $incStats = true)
    {
        if ($this->getCompletedAt()) {
            throw new \RuntimeException('Cannot fail job as it\'s been completed');
        }

        $this->setCompletedAt(time());

        $history = new \Furnace\Entity\History(array(
            'startedAt' => $this->getStartedAt() ?: time(),
            'failedAt' => $this->getCompletedAt(),
            'message' => $message,
        ));

        if ($incStats && $this->getPidOf()) {
            $history->setStats($this->getStats());
        }

        $this->unshiftHistory($history);

        $this->clear(array('startedAt', 'queuedAt'));
        $this->setError(true);

        $this->addMessages(sprintf('Job failed at %s: %s',
            date('Y-m-d H:i:s', $this->getCompletedAt()->getTimestamp()),
            $message
        ));

        return $this;
    }

    /**
     * Sets the schedule/start time for a job. Similar to calling
     * setSchedule/setStartAt directly, expect that additional validation
     * is done which throws exceptions upon misconfiguration.
     *
     * @param   string                              Schedule (daily, weekly, etc.)
     * @param   DateTime|string|integer             When the job starts (date, time or both based
     *                                                  on the value from schedule)
     * @return  $this
     */
    public function schedule($schedule, $startAt = null)
    {
        $timestamp = $this->getTimestampFromArgument($startAt);

        $this->setStartAt($timestamp)
             ->setSchedule($schedule);

        if (!$this->isValid('schedule')) {
            throw new \InvalidArgumentException('$schedule invalid, not in list of allowed '
                . 'values.'
            );
        }

        if ($schedule == 'once' && $timestamp < time()) {
            throw new \RuntimeException('$schedule of once must include a start date/time '
                . 'in the future, ' . date('Y-m-d H:i:s') . ' given.'
            );
        }

        return $this;
    }

}
